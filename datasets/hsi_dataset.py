"""
Dataset utils for HSI classification
# Author: LQY @ HIT
# Modified by: HX @ HIT
# Email: 21B905003@stu.hit.edu.cn, 19B905007@stu.hit.edu.cn
"""
import numpy as np
from pathlib import Path
from typing import Callable, Optional, Dict

import scipy.io as sio

import torch
from torch import from_numpy as fn
from torch.utils.data import TensorDataset
from torchvision.datasets import VisionDataset
import torchvision
import random

dataset_types = ('train', 'val', 'test')


class CachedHSIDataset(VisionDataset):
    """
    Args:
        data_path (pathlib.Path/str): File path of the HSI data.
        gt_path (pathlib.Path/str): File path of the HSI gt.
        transform (callable, optional): A function/transform that takes in an PIL image
            and returns a transformed version. E.g, ``transforms.RandomCrop``
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
    """

    def __init__(
            self,
            data_path: 'Path, str',
            gt_path: 'Path, str',
            transform: Optional[Callable] = None,
            target_transform: Optional[Callable] = None,
    ):

        self.data_path = data_path if isinstance(data_path, Path) else Path(data_path)
        self.gt_path = gt_path if isinstance(gt_path, Path) else Path(gt_path)

        super(CachedHSIDataset, self).__init__(
            str(self.data_path.parent), transform=transform,
            target_transform=target_transform)

        imgs = torch.tensor(np.load(str(self.data_path)))
        anns = torch.tensor(np.load(str(self.gt_path)))

        self.dataset = TensorDataset(imgs, anns)

    def __getitem__(self, idx):
        img, target = self.dataset[idx]

        if self.transform is not None:
            img = self.transform(img)

        if self.target_transform is not None:
            target = self.target_transform(target)

        return img, target

    def __len__(self) -> int:
        return len(self.dataset)


class HSIDataset(VisionDataset):
    """
    Args:
        data_path (pathlib.Path/str): File path of the HSI data.
        gt_path (pathlib.Path/str): File path of the HSI gt.
        info_path (pathlib.Path/str): File path of the split info generated by builder.
        dataset_type (str): train, val or test set.
        transform (callable, optional): A function/transform that takes in an PIL image
            and returns a transformed version. E.g, ``transforms.RandomCrop``
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
    """

    def __init__(self,
                 data_path: 'Path, str',
                 gt_path: 'Path, str',
                 info_path: 'Path, str',
                 dataset_type: str,
                 transform: Optional[Callable] = None,
                 target_transform: Optional[Callable] = None,):

        self.data_path = data_path if isinstance(data_path, Path) else Path(data_path)
        self.gt_path = gt_path if isinstance(gt_path, Path) else Path(gt_path)
        self.info_path = gt_path if isinstance(info_path, Path) else Path(info_path)

        transform = transform.get(dataset_type, None) \
            if isinstance(transform, Dict) else transform
        target_transform = target_transform.get(dataset_type, None) \
            if isinstance(target_transform, Dict) else target_transform

        super(HSIDataset, self).__init__(str(self.data_path.parent),
                                         transform=transform,
                                         target_transform=target_transform)
        # load split info
        info = sio.loadmat(info_path)
        self.coords = info['coords']
        self.RandPerm = info['RandPerm'].squeeze()
        self.window_size = info['window_size'].item()
        assert self.window_size % 2 == 1, ValueError(
            f"The window_size {self.window_size} ought "
            "to be a singular number")
        self.half_window = self.window_size // 2
        self.use_edge = info['use_edge'].item()
        self.train = info['train'].item()
        self.val = info['val'].item()

        self.indices = None
        assert dataset_type in dataset_types
        self.dataset_type = dataset_type

        # load meta data and gt
        data = {k: v for k, v in sio.loadmat(data_path).items()
                     if isinstance(v, np.ndarray)}
        gt = {k: v for k, v in sio.loadmat(gt_path).items()
                   if isinstance(v, np.ndarray) and 'map' not in k}
        assert len(data) == 1 and len(gt) == 1, \
            ValueError('Description Reading the MAT file conflicts.')
        data, gt = list(data.values())[0], list(gt.values())[0]

        # pre-processing
        data = 1 * ((data - np.min(data)) / (np.max(data) - np.min(data)) )  #归一化方式改变


        self.data = data.transpose([2, 0, 1])  # H, W, C --> C, H, W
        self.gt = gt - 1

    @property
    def dataset_type(self):
        return self._dataset_type

    @dataset_type.setter
    def dataset_type(self, value):
        self._dataset_type = value
        train, val = self.train, self.val
        trainval = train + val
        # set base item
        if self.dataset_type == 'train':
            self.indices = self.RandPerm[:train]
        elif self.dataset_type == 'val':
            self.indices = self.RandPerm[train:trainval]
        else:
            self.indices = self.RandPerm[trainval:]

    def __getitem__(self, item):
        ind = self.indices[item]
        coord_x, coord_y = self.coords[ind]
        half_window = self.half_window

        half_window2=0
        img_spectral=fn(self.data[:,
                 coord_x - half_window2: coord_x + half_window2+ 1,
                 coord_y - half_window2: coord_y + half_window2+ 1
                 ].astype(np.float32))


        img = fn(self.data[:,
                 coord_x - half_window: coord_x + half_window + 1,
                 coord_y - half_window: coord_y + half_window + 1
                 ].astype(np.float32))
        target = self.gt[coord_x, coord_y].astype(np.int64)
        target = fn(np.array(target))

        if self.transform is not None:
            img = self.transform(img)

        if self.target_transform is not None:
            target = self.target_transform(target)

        # if return_spectral:
        #     return img, target, img_spectral
        # else:
        return img, target, img_spectral

    def __len__(self):
        return len(self.indices)